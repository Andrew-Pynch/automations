[{"role": "user", "content": "write a quick python script that recursively searches files in cwd for '# TODO' or '# ASSUMPTION' or just any category in categories=['TODO', 'ASSUMPTION', etc]. then print out a report of these statuses that looks like 'ASSUMPTIONS\\n\\tmain.py (line 14)\\n\\t\\t- function is holomorphic\\n\\t\\t- user will only enter numbers here\\n\\n\\tdata_loader.py...\n'"}, {"role": "assistant", "content": "```\nimport os,re\ndef search():\n c={}\n for r,_,fs in os.walk('.'):\n  for f in fs:\n   if f.endswith('.py'):\n    p=os.path.join(r,f)\n    with open(p) as F:\n     for i,l in enumerate(F):\n      m=re.search(r'#\\s*(\\w+)\\s*:?\\s*(.*)',l)\n      if m:\n       t,n=m.groups()\n       if t in ['TODO','ASSUMPTION']:\n        c.setdefault(t,[]).append((p,i+1,n.strip()))\n for t in c:\n  print(f\"{t}S\")\n  for p,i,n in c[t]:\n   print(f\"\\t{p} (line {i})\\n\\t\\t- {n}\")\n  print()\nsearch()\n```"}, {"role": "user", "content": "ok now make this readable with comments"}, {"role": "assistant", "content": "\n\n```python\nimport os, re\n\ndef search_todos_and_assumptions():\n    # Dictionary to store findings by category\n    categories = {}\n    \n    # Walk through all directories and files\n    for root, _, files in os.walk('.'):\n        for file in files:\n            # Only check Python files\n            if file.endswith('.py'):\n                path = os.path.join(root, file)\n                with open(path) as f:\n                    # Check each line for comments\n                    for i, line in enumerate(f):\n                        # Look for comments with category markers\n                        match = re.search(r'#\\s*(\\w+)\\s*:?\\s*(.*)', line)\n                        if match:\n                            category, note = match.groups()\n                            if category in ['TODO', 'ASSUMPTION']:\n                                # Add to our findings\n                                categories.setdefault(category, []).append((path, i+1, note.strip()))\n    \n    # Print the report\n    for category in categories:\n        print(f\"{category}S\")  # Pluralize the category\n        for path, line_num, note in categories[category]:\n            print(f\"\\t{path} (line {line_num})\")\n            print(f\"\\t\\t- {note}\")\n        print()  # Empty line between categories\n\nsearch_todos_and_assumptions()\n```"}, {"role": "user", "content": "ok now make this ignore dirs and file types using a list of strings defined at the top of the file. use gitignore style ignoring."}, {"role": "assistant", "content": "\n\n```python\nimport os, re, fnmatch\n\ndef search_todos_and_assumptions():\n    # Configuration\n    ignore_dirs = ['.git', 'node_modules', 'venv', '__pycache__', 'build', 'dist']\n    ignore_file_patterns = ['*.pyc', '*.pyo', '*.so', '*.dll', '*.exe', '*.pdf', '*.jpg', '*.png']\n    categories = ['TODO', 'ASSUMPTION']\n    \n    # Dictionary to store findings by category\n    findings = {}\n    \n    # Walk through all directories and files\n    for root, dirs, files in os.walk('.'):\n        # Remove ignored directories from dirs to prevent recursion into them\n        dirs[:] = [d for d in dirs if d not in ignore_dirs]\n        \n        for file in files:\n            # Skip files matching ignore patterns\n            if any(fnmatch.fnmatch(file, pattern) for pattern in ignore_file_patterns):\n                continue\n                \n            path = os.path.join(root, file)\n            try:\n                with open(path, 'r', encoding='utf-8') as f:\n                    # Check each line for comments\n                    for i, line in enumerate(f):\n                        # Look for comments with category markers\n                        match = re.search(r'#\\s*(\\w+)\\s*:?\\s*(.*)', line)\n                        if match:\n                            category, note = match.groups()\n                            if category in categories:\n                                # Add to our findings\n                                findings.setdefault(category, []).append((path, i+1, note.strip()))\n            except (UnicodeDecodeError, IOError):\n                # Skip files that can't be read as text\n                continue\n    \n    # Print the report\n    for category in findings:\n        print(f\"{category}S\")  # Pluralize the category\n        for path, line_num, note in findings[category]:\n            print(f\"\\t{path} (line {line_num})\")\n            print(f\"\\t\\t- {note}\")\n        print()  # Empty line between categories\n\nsearch_todos_and_assumptions()\n```"}, {"role": "user", "content": "doesnt ignore *.venv"}, {"role": "assistant", "content": "```python\nimport os, re, fnmatch\n\ndef search_todos_and_assumptions():\n    # Configuration\n    ignore_dirs = ['.git', 'node_modules', 'venv', '.venv', '__pycache__', 'build', 'dist']\n    ignore_file_patterns = ['*.pyc', '*.pyo', '*.so', '*.dll', '*.exe', '*.pdf', '*.jpg', '*.png']\n    categories = ['TODO', 'ASSUMPTION']\n    \n    # Dictionary to store findings by category\n    findings = {}\n    \n    # Walk through all directories and files\n    for root, dirs, files in os.walk('.'):\n        # Remove ignored directories from dirs to prevent recursion into them\n        dirs[:] = [d for d in dirs if d not in ignore_dirs and not any(fnmatch.fnmatch(d, pattern) for pattern in ignore_dirs)]\n        \n        for file in files:\n            # Skip files matching ignore patterns\n            if any(fnmatch.fnmatch(file, pattern) for pattern in ignore_file_patterns):\n                continue\n                \n            path = os.path.join(root, file)\n            try:\n                with open(path, 'r', encoding='utf-8') as f:\n                    # Check each line for comments\n                    for i, line in enumerate(f):\n                        # Look for comments with category markers\n                        match = re.search(r'#\\s*(\\w+)\\s*:?\\s*(.*)', line)\n                        if match:\n                            category, note = match.groups()\n                            if category in categories:\n                                # Add to our findings\n                                findings.setdefault(category, []).append((path, i+1, note.strip()))\n            except (UnicodeDecodeError, IOError):\n                # Skip files that can't be read as text\n                continue\n    \n    # Print the report\n    for category in findings:\n        print(f\"{category}S\")  # Pluralize the category\n        for path, line_num, note in findings[category]:\n            print(f\"\\t{path} (line {line_num})\")\n            print(f\"\\t\\t- {note}\")\n        print()  # Empty line between categories\n\nsearch_todos_and_assumptions()\n```"}]